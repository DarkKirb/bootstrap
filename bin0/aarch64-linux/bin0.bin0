01000110 01001100 01000101 01111111 # ELF Magic
00000000 00000001 00000001 00000010 # 32 bit little endian elf
00000000000000000000000000000000
00000000000000000000000000000000 # padding
0000000010110111 0000000000000010 # ARM64 ELF
00000000000000000000000000000001 # original version ELF
00000000001000000000000001111000
00000000000000000000000000000000 # Entrypoint
00000000000000000000000001000000
00000000000000000000000000000000 # Program header table position
00000000000000000000000000000000
00000000000000000000000000000000 # Section Header table position
00000000000000000000000000000000 # Flags
0000000000111000 0000000001000000 # Header size, size of one ph entry
0000000001000000 0000000000000001 # One program header, section header size
0000000000000000 0000000000000000 # no section headers, no section name section

00000000000000000000000000000001 # PT_LOAD
00000000000000000000000000000111 # rwx
00000000000000000000000000000000
00000000000000000000000000000000 # Load from zero
00000000001000000000000000000000
00000000000000000000000000000000 # Load at 2MB
00000000001000000000000000000000
00000000000000000000000000000000 # same but physical address
00000000000000000000000100111100
00000000000000000000000000000000 # filesz
00000000000000000000000100111100
00000000000000000000000000000000 # memsz
00000000000000000000000000000100
00000000000000000000000000000000 # Align
#.section .text
#.global _start
#
#_start:
11 111 0 01 01 0 00000000000 11111 00000  #    ldr xO, [sp] // Get argc
0 1 1 100010 0 000000000011 00000 11111   #    cmp xO, #3 // Check if argc is 3
0101010 0 0000000000000101110 0 1011      #    blt exit // exit otherwise
#
1 00 100101 00 0000000001100011 00000     #    mov xO, #-lOO // AT_FDCWD
11 111 0 01 01 0 00000000010 11111 00001  #    ldr xl, [sp, l6] // First argument
1 10 100101 00 0000000000000000 00010     #    mov x2, #O // O_RDONLY
1 10 100101 00 0000000000000000 00011     #    mov x3, #O // no mode
1 10 100101 00 0000000000111000 01000     #    mov x8, #56 // openat
11010100 000 0000000000000000 000 01      #    svc #O
1 1 1 100010 0 000000000000 00000 11111   #    cmp xO, #O // Check if openat succeeded
0101010 0 0000000000000100110 0 1011      #    blt exit // exit otherwise
1 01 01010 00 0 00000 000000 11111 01001  #    mov x9, xO // Save fd
#
1 00 100101 00 0000000001100011 00000     #    mov xO, #-lOO // AT_FDCWD
11 111 0 01 01 0 00000000011 11111 00001  #    ldr xl, [sp, 24] // Second argument
1 10 100101 00 0000001001000001 00010     #    mov x2, #577 // O_TRUNC | O_CREAT | O_WRONLY
1 10 100101 00 0000000111101101 00011     #    mov x3, #493 // rwxr-xr-x
1 10 100101 00 0000000000111000 01000     #    mov x8, #56 // openat
11010100 000 0000000000000000 000 01      #    svc #O
1 1 1 100010 0 000000000000 00000 11111   #    cmp xO, #O // Check if openat succeeded
0101010 0 0000000000000011101 0 1011      #    blt exit // exit otherwise
1 01 01010 00 0 00000 000000 11111 01010  #    mov xlO, xO // Save fd
#
#.Lloop_init:
1 10 100101 00 0000000000000000 01011     #    mov xll, #O // load accumulator
1 10 100101 00 0000000000100000 01100     #    mov xl2, #32 // Counter
#.Lread_loop:
1 01 01010 00 0 01001 000000 11111 00000  #    mov xO, x9 // source fd
1 0 0 100010 0 000000000000 11111 00001   #    mov xl, sp // destination buffer
1 10 100101 00 0000000000000001 00010     #    mov x2, #l // size
1 10 100101 00 0000000000111111 01000     #    mov x8, #63 // read
11010100 000 0000000000000000 000 01      #    svc #O
1 1 1 100010 0 000000000000 00000 11111   #    cmp xO, #O // Check if read succeessful
0101010 0 0000000000000010011 0 1101      #    ble exit // exit otherwise
#
#    // read the byte
00 111 0 01 01 0 00000000000 11111 00000  #    ldrb wO, [sp]
0 00 100100 0 011111 000110 00000 00000   #    and wO, wO, #OxFE // clear the bottom bit
0 1 1 100010 0 000000110000 00000 11111   #    cmp wO, #Ox3O // Check if the byte is a number
0101010 0 1111111111111110110 0 0001      #    bne .Lread_loop // if not, loop again
#
00 111 0 01 01 0 00000000000 11111 00000  #    ldrb wO, [sp]
0 00 100100 0 000000 000000 00000 00000   #    and wO, wO, #l // get the bottom bit
0 01 01010 00 0 01011 000001 00000 01011  #    orr wll, wO, wll, lsl #l // add the bit to the accumulator
1 1 1 100010 0 000000000001 01100 01100   #    subs xl2, xl2, #l // decrement counter
0101010 0 1111111111111110001 0 0001      #    bne .Lread_loop // we havenâ€™t finished looping
#
10 111 0 01 00 0 00000000000 11111 01011  #    str wll, [sp] // store the accumulator
1 01 01010 00 0 01010 000000 11111 00000  #    mov xO, xlO // destination fd
1 0 0 100010 0 000000000000 11111 00001   #    mov xl, sp // source buffer
1 10 100101 00 0000000000000100 00010     #    mov x2, #4 // size
1 10 100101 00 0000000001000000 01000     #    mov x8, #64 // write
11010100 000 0000000000000000 000 01      #    svc #O
1 1 1 100010 0 000000000000 00000 11111   #    cmp xO, #O // Check if read succeessful
0101010 0 0000000000000000010 0 1011      #    blt exit // exit otherwise
0 00101 11111111111111111111100110        #    b .Lloop_init
#
#exit:
1 10 100101 00 0000000001011101 01000     #    mov x8, #93
11010100 000 0000000000000000 000 01      #    svc #O
