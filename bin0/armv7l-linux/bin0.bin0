01000110 01001100 01000101 01111111 # ELF Magic
00000000 00000001 00000001 00000001 # 32 bit little endian elf
00000000000000000000000000000000
00000000000000000000000000000000 # padding
0000000000101000 0000000000000010 # ARM ELF
00000000000000000000000000000001 # original version ELF
00000000001000000000000001010100 # Program Entry position
00000000000000000000000000110100 # Program header table position
00000000000000000000000001010100 # Section Header table position
00000000000000000000000000000000 # Flags
0000000000100000 0000000000110100 # Header Size, Size of an entry in the program header table
0000000000101000 0000000000000001 # One program header, section header size
0000000000000000 0000000000000000 # no section headers, no section name section

00000000000000000000000000000001 # PT_LOAD
00000000000000000000000000000000 # Load from ZERO
00000000001000000000000000000000 # Load at 2MB
00000000001000000000000000000000 # Who cares about physical address
00000000000000000000000100100000 # size
00000000000000000000000100100000 # memory size
00000000000000000000000000000111 # rwx
00000000000000000000000000000100 # align 4 bytes


#.section .text
#.global _start
#
#_start:
1110 010 1 1 0 0 1 1101 0000 0000 0000 0000 #    ldr rO, [sp, O] // Get argc
1110 00 1 1010 1 0000 0000 0000 0000 0011   #    cmp rO, #3 // Check if argc is 3
1011 0011 0000 0000 0111 0000 0000 0001     #    movlt r7, #l // exit(l)
1011 1111 0000 0000 0000 0000 0000 0000     #    svclt #O
#
1110 00 1 1111 0 0000 0000 0000 0110 0011   #    mov rO, #-lOO // AT_FDCWD
1110 010 1 1 0 0 1 1101 0001 0000 0000 1000 #    ldr rl, [sp, 8] // first argument
1110 00 1 1101 0 0000 0010 0000 0000 0000   #    mov r2, #O // O_RDONLY
1110 00 1 1101 0 0000 0011 0000 0000 0000   #    mov r3, #O // no mode
1110 0011 0000 0000 0111 0001 0100 0010     #    mov r7, #322 // openat
1110 1111 0000 0000 0000 0000 0000 0000     #    svc #O
1110 00 1 1010 1 0000 0000 0000 0000 0000   #    cmp rO, #O // Check if failed
1011 0011 0000 0000 0111 0000 0000 0001     #    movlt r7, #l // exit(l)
1011 1111 0000 0000 0000 0000 0000 0000     #    svclt #O
1110 00 0 1101 0 0000 1000 00000000 0000    #    mov r8, rO
#
1110 00 1 1111 0 0000 0000 0000 0110 0011   #    mov rO, #-lOO // AT_FDCWD
1110 010 1 1 0 0 1 1101 0001 0000 0000 1100 #    ldr rl, [sp, l2] // first argument
1110 0011 0000 0000 0010 0010 0100 0001     #    mov r2, #577 // O_TRUNC | O_CREAT | O_WRONLY
1110 0011 0000 0000 0011 0001 1110 1101     #    mov r3, #493 // rwxr-xr-x
1110 0011 0000 0000 0111 0001 0100 0010     #    mov r7, #322 // openat
1110 1111 0000 0000 0000 0000 0000 0000     #    svc #O
1110 00 1 1010 1 0000 0000 0000 0000 0000   #    cmp rO, #O // Check if failed
1011 0011 0000 0000 0111 0000 0000 0001     #    movlt r7, #l // exit(l)
1011 1111 0000 0000 0000 0000 0000 0000     #    svclt #O
1110 00 0 1101 0 0000 1001 00000000 0000    #    mov r9, rO
#
#.Lloop_init:
1110 00 1 1101 0 0000 1010 0000 0000 0001   #    mov rlO, #l // load accumulator
#.Lread_loop:
1110 00 0 1101 0 0000 0000 00000000 1000    #    mov rO, r8 // Source FD
1110 00 0 1101 0 0000 0001 00000000 1101    #    mov rl, sp // Destination buffer
1110 00 1 1101 0 0000 0010 0000 0000 0001   #    mov r2, #l // Number of bytes to read
1110 00 1 1101 0 0000 0111 0000 0000 0011   #    mov r7, #3 // read()
1110 1111 0000 0000 0000 0000 0000 0000     #    svc #O
1110 00 1 1010 1 0000 0000 0000 0000 0000   #    cmp rO, #O // Check if failed or end of file
1101 0011 0000 0000 0111 0000 0000 0001     #    movle r7, #l // exit(l)
1101 1111 0000 0000 0000 0000 0000 0000     #    svcle #O
#
#    // read the byte
1110 010 1 1 1 0 1 1101 0000 0000 0000 0000 #    ldrb rO, [sp]
1110 00 1 0000 0 0000 0000 0000 1111 1110   #    and rO, rO, #OxFE // remove bottom bit
1110 00 1 1010 1 0000 0000 0000 0011 0000   #    cmp rO, #Ox3O // Check if it's a number
0001 1010 1111 1111 1111 1111 1111 0011     #    bne .Lread_loop // If not, go back to read again
#
1110 010 1 1 1 0 1 1101 0000 0000 0000 0000 #    ldrb rO, [sp]
1110 00 1 0000 0 0000 0000 0000 0000 0001   #    and rO, rO, #OxOl // mask the bottom bit
1110 00 0 1100 1 0000 1010 00001 00 0 1010  #    orrs rlO, rO, rlO, lsl #l // Add the number to the accumulator
0011 1010 1111 1111 1111 1111 1110 1111     #    bcc .Lread_loop // We havenâ€™t finished reading
#
1110 010 1 1 0 0 0 1101 1010 0000 0000 0000 #    str rlO, [sp] // Store the accumulator
1110 00 0 1101 0 0000 0000 00000000 1001    #    mov rO, r9 // Destination FD
1110 00 0 1101 0 0000 0001 00000000 1101    #    mov rl, sp // Source buffer
1110 00 1 1101 0 0000 0010 0000 0000 0100   #    mov r2, #4 // Number of bytes to write
1110 00 1 1101 0 0000 0111 0000 0000 0100   #    mov r7, #4 // write()
1110 1111 0000 0000 0000 0000 0000 0000     #    svc #O
1110 00 1 1010 1 0000 0000 0000 0000 0000   #    cmp rO, #O // Check if failed
1011 0011 0000 0000 0111 0000 0000 0001     #    movlt r7, #l // exit(l)
1011 1111 0000 0000 0000 0000 0000 0000     #    svclt #O
#
1110 1010 1111 1111 1111 1111 1110 0100     #    b .Lloop_init
