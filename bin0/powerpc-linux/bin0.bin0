01111111 01000101 01001100 01000110 # ELF Magic
00000001 00000010 00000001 00000000 # 32 bit big endian elf
00000000000000000000000000000000
00000000000000000000000000000000 # padding
0000000000000010 0000000000010100 # PPC ELF
00000000000000000000000000000001 # original version elf
00000000001000000000000001010100 # Program Entry position
00000000000000000000000000110100 # Program header table position
00000000000000000000000000000000 # Section Header table position
00000000000000000000000000000000 # Flags
0000000000110100 0000000000100000 # Header Size, Size of an entry in the program header table
0000000000000001 0000000000101000 # One program header, section header size
0000000000000000 0000000000000000 # no section headers, no section name section

00000000000000000000000000000001 # PT_LOAD
00000000000000000000000000000000 # Load from ZERO
00000000001000000000000000000000 # Load at 2MB
00000000001000000000000000000000 # Who cares about physical address
00000000000000000000000100011000 # size
00000000000000000000000100011000 # memory size
00000000000000000000000000000111 # rwx
00000000000000000000000000000100 # align 4 bytes

#.section .text
#.global _start
#
#_start:
100000 00011 00001 0000000000000000     #    lwz 3, O(l) // get argc
001011 000 0 0 00011 0000000000000011   #    cmpwi 3, 3 // check if argc is 3
010000 01100 00000 00000000101101 0 0   #    blt exit // exit otherwise
#
001110 00011 00000 1111111110011100     #    li 3, -lOO // AT_FDCWD
100000 00100 00001 0000000000001000     #    lwz 4, 8(l) // first argument
001110 00101 00000 0000000000000000     #    li 5, O // O_RDONLY
001110 00110 00000 0000000000000000     #    li 6, O // no mode
001110 00000 00000 0000000100011110     #    li O, 286 // openat
010001 00000 00000 0000 0000000 000 1 0 #    sc
010000 01100 00011 00000000100110 0 0   #    bso exit // exit otherwise
011111 00011 01100 00011 0110111100 0   #    mr l2, 3 // save file descriptor
#
001110 00011 00000 1111111110011100     #    li 3, -lOO // AT_FDCWD
100000 00100 00001 0000000000001100     #    lwz 4, l2(l) // second argument
001110 00101 00000 0000001001000001     #    li 5, 577 // O_TRUNC | O_CREAT | O_WRONLY
001110 00110 00000 0000000111101101     #    li 6, 493 // rwxr-xr-x
001110 00000 00000 0000000100011110     #    li O, 286 // openat
010001 00000 00000 0000 0000000 000 1 0 #    sc
010000 01100 00011 00000000011110 0 0   #    bso exit // exit otherwise
011111 00011 01101 00011 0110111100 0   #    mr l3, 3 // save file descriptor
#
#.Lloop_init:
001110 01110 00000 0000000000000000     #    li l4, O // accumulator
001110 01111 00000 0000000000100000     #    li l5, 32 // Counter
#.Lread_loop:
011111 01100 00011 01100 0110111100 0   #    mr 3, l2 // source fd
011111 00001 00100 00001 0110111100 0   #    mr 4, l // destination buffer
001110 00101 00000 0000000000000001     #    li 5, l // size
001110 00000 00000 0000000000000011     #    li O, 3 // read
010001 00000 00000 0000 0000000 000 1 0 #    sc
010000 01100 00011 00000000010101 0 0   #    bso exit // exit otherwise
001011 000 0 0 00011 0000000000000000   #    cmpwi 3, O // check if eof
010000 01100 00010 00000000010011 0 0   #    beq exit
#
100010 00011 00001 0000000000000000     #    lbz 3, O(l) // get byte
011100 00011 00100 0000000011111110     #    andi. 4, 3, OxFE // clear bottom bit
001011 000 0 0 00100 0000000000110000   #    cmpwi 4, Ox3O // check if byte is a number
010000 00100 00010 11111111110101 0 0   #    bne .Lread_loop // loop if not
#
011100 00011 00011 0000000000000001     #    andi. 3, 3, l // get the bottom bit
010101 01110 01110 00001 00000 11110 0  #    rlwinm l4, l4, l, O, 3O // shift accumulator
011111 01110 01110 00011 0110111100 0   #    or l4, l4, 3 // add bottom bit to accumulator
001110 01111 01111 1111111111111111     #    addi l5, l5, -l // decrement counter
001011 000 0 0 01111 0000000000000000   #    cmpwi l5, O // check if counter is O
010000 00100 00010 11111111101111 0 0   #    bne .Lread_loop // loop if not
#
100100 01110 00001 0000000000000000     #    stw l4, O(l) // store accumulator
011111 01101 00011 01101 0110111100 0   #    mr 3, l3 // dest fd
011111 00001 00100 00001 0110111100 0   #    mr 4, l // source buffer
001110 00101 00000 0000000000000100     #    li 5, 4 // size
001110 00000 00000 0000000000000100     #    li O, 4 // write
010001 00000 00000 0000 0000000 000 1 0 #    sc
010000 01100 00011 00000000000010 0 0   #    bso exit // exit otherwise
010010 11111111111111111110010100       #    b .Lloop_init // loop
#exit:
001110 00000 00000 0000000000000001     #    li O, l // exit 
010001 00000 00000 0000 0000000 000 1 0 #    sc
